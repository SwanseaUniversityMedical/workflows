name: 'Build, Test and Release Container'
inputs:
  job-name:
    description: "Job name to display on Slack messages."
    required: true
    type: string

  comment-header:
    description: "Header line for the Release summary."
    default: ":whale: Build Release Container"
    type: string

  build-file:
    description: "Path to the container file."
    required: true
    type: string

  build-context:
    description: "Path to the build root dir."
    default: '.'
    type: string

  test-flags:
    description: "Arguments passed to docker run."
    default: ''
    type: string

  test-args:
    description: "Arguments passed to the container."
    default: ''
    type: string

  registry:
    description: "URL of the container registry."
    required: true
    type: string

  registry-user:
    description: "Username for the container registry."
    required: true
    type: string

  registry-repo:
    description: "Repo within container registry project."
    required: true
    type: string

  registry-extra-tag-command:
    description: "Extra tag to push release container."
    default: ''
    type: string

  release-tag-format:
    description: "Semantic-release Github release tag format."
    default: '${version}'
    type: string

  cosign-public-key:
    description: "Public key for cosigning images."
    required: false
    type: string

  registry-token:
    description: "Authentication token for the container registry."
    required: true

  cosign-private-key:
    description: "Private key for cosigning images."
    required: false

  cosign-password:
    description: "Private key password for cosigning images."
    required: false

runs:
  using: "composite"
  steps:
    - name: determine release
      id: determine-release
      uses: actions/github-script@v7.0.1
      with:
        script: |
          var inputs = ${{ toJSON(inputs) }};
          var asset = inputs['job-name'].trim();

          var major = `major: ${asset}`;
          core.setOutput("major", major);

          var minor = `minor: ${asset}`;
          core.setOutput("minor", minor);

          var patch = `patch: ${asset}`;
          core.setOutput("patch", patch);

          try {
            await github.rest.issues.createLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: major,
              color: "B60205"
            });
          } catch (error) {
            console.log(error);
          }

          try {
            await github.rest.issues.createLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: minor,
              color: "8BD931"
            });
          } catch (error) {
            console.log(error);
          }

          try {
            await github.rest.issues.createLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: patch,
              color: "FBCA04"
            });
          } catch (error) {
            console.log(error);
          }

          var result = await github.rest.repos.listPullRequestsAssociatedWithCommit({
            owner: context.repo.owner,
            repo: context.repo.repo,  
            commit_sha: context.sha,
          });

          if (result.data.length > 0) {
            if (result.data.length > 1) {
              core.warning("Found multiple pull requests associated with the current commit!");
            }

            for (let i = 0; i < result.data.length; i++) {
              var pr = result.data[i];
              core.debug(JSON.stringify(pr));

              if ((pr.base.ref === context.ref) && (pr.state === 'closed') && (pr.merge_commit_sha === context.sha)) {
                core.info("Found pull request " + pr.number + " which created the current commit " + context.sha);
                core.setOutput("number", pr.number);

                var labels = await github.rest.issues.listLabelsOnIssue({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                });

                core.debug(JSON.stringify(labels));
                core.setOutput("labels", JSON.stringify(labels));

                if (labels.includes(major)) {
                  core.info("next release will be major");
                  core.setOutput("release", "major");
                }
                else if (labels.includes(minor)) {
                  core.info("next release will be minor");
                  core.setOutput("release", "minor");
                }
                else if (labels.includes(patch)) {
                  core.info("next release will be patch");
                  core.setOutput("release", "patch");
                }
                else {
                  core.info("next release will be skipped");
                  core.setOutput("release", "");
                }

                return;
              } 
            }
          }
          
          core.setFailed("Could not find pr to extract labels from.");
          

    - name: semantic release
      uses: docker://harbor.ukserp.ac.uk/github-workflows/semantic-release-action:v3
      id: semantic
      env:
        GITHUB_TOKEN: ${{ github.token }}
      with:
        dry-run: true
        branches: ${{ github.ref }}
        tag-format: ${{ inputs.release-tag-format }}
        additional-packages: |
          ['@semantic-release/exec']
        plugins: |-
          [
            ['@semantic-release/exec', {
              "analyzeCommitsCmd": "printf \"%s\" \"${{ steps.determine-release.outputs.release }}\"",
            }]
          ]

    - name: install cosign
      if: steps.semantic.outputs.new-release-published == 'true' && inputs.cosign-public-key != ''
      uses: sigstore/cosign-installer@v3.1.2

    - name: forward proxy settings
      if: steps.semantic.outputs.new-release-published == 'true'
      shell: bash
      run: |
        echo "HTTP_PROXY=$HTTP_PROXY" >> $GITHUB_ENV
        echo "HTTPS_PROXY=$HTTPS_PROXY" >> $GITHUB_ENV
        echo "NO_PROXY=$NO_PROXY" >> $GITHUB_ENV

    - name: install buildx
      if: steps.semantic.outputs.new-release-published == 'true'
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          env.http_proxy=${{ env.HTTP_PROXY }}
          env.https_proxy=${{ env.HTTPS_PROXY }}
          "env.no_proxy='${{ env.NO_PROXY }}'"
        buildkitd-config-inline: |
          [registry."docker.io"]
            mirrors = ["https://harbor.ukserp.ac.uk/proxycache"]
          [registry."quay.io"]
            mirrors = ["https://harbor.ukserp.ac.uk/quaycache"]
          [registry."ghcr.io"]
            mirrors = ["https://harbor.ukserp.ac.uk/ghcrcache"]
          [registry."mcr.microsoft.com"]
            mirrors = ["https://harbor.ukserp.ac.uk/microsoftcache"]

    - name: login to container registry
      if: steps.semantic.outputs.new-release-published == 'true'
      uses: docker/login-action@v3
      with:
        registry: ${{ inputs.registry }}
        username: ${{ inputs.registry-user }}
        password: ${{ inputs.registry-token }}

    - name: new release
      if: steps.semantic.outputs.new-release-published == 'true'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: |
          #### ${{ inputs.comment-header }} - ${{ inputs.job-name }} - :label: Commit: ${{ github.sha }}
          :label: New version will be ${{ steps.semantic.outputs.release-version }}  

    - name: skipped release
      if: steps.semantic.outputs.new-release-published != 'true'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: |
          #### ${{ inputs.comment-header }} - ${{ inputs.job-name }} - :label: Commit: ${{ github.sha }}  
          :desert_island: Skipping release!

    - name: cache container metadata
      if: steps.semantic.outputs.new-release-published == 'true'
      uses: docker/metadata-action@v5
      id: branch-recent-meta
      with:
        images: |
          ${{ inputs.registry }}/${{ inputs.registry-repo }}
        tags: |
          type=ref,event=branch,prefix=rc-

    - name: pr cache container metadata
      if: steps.semantic.outputs.new-release-published == 'true'
      uses: docker/metadata-action@v5
      id: pr-recent-meta
      with:
        images: |
          ${{ inputs.registry }}/${{ inputs.registry-repo }}
        tags: |
          type=raw,value=pr-recent

    - name: rc cache container metadata
      if: steps.semantic.outputs.new-release-published == 'true'
      uses: docker/metadata-action@v5
      id: rc-recent-meta
      with:
        images: |
          ${{ inputs.registry }}/${{ inputs.registry-repo }}
        tags: |
          type=raw,value=rc-recent

    - name: rc container metadata
      if: steps.semantic.outputs.new-release-published == 'true'
      uses: docker/metadata-action@v5
      id: rc-meta
      with:
        images: |
          ${{ inputs.registry }}/${{ inputs.registry-repo }}
        tags: |
          type=raw,value=rc-${{ steps.semantic.outputs.release-version }}

    - name: release container metadata
      if: steps.semantic.outputs.new-release-published == 'true'
      uses: docker/metadata-action@v5
      id: meta
      with:
        images: |
          ${{ inputs.registry }}/${{ inputs.registry-repo }}
        tags: |
          type=raw,value=${{ steps.semantic.outputs.release-version }}

    - name: build rc container
      if: steps.semantic.outputs.new-release-published == 'true'
      uses: docker/build-push-action@v5
      id: build-rc
      with:
        file: ${{ inputs.build-file }}
        context: ${{ inputs.build-context }}
        tags: |
          ${{ steps.rc-meta.outputs.tags }}
          ${{ steps.branch-recent-meta.outputs.tags }}
          ${{ steps.rc-recent-meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        push: true
        github-token: ${{ github.token }}
        provenance: true
        cache-to: type=inline
        cache-from: |
          type=registry,ref=${{ steps.branch-recent-meta.outputs.tags }}
          type=registry,ref=${{ steps.rc-recent-meta.outputs.tags }}
          type=registry,ref=${{ steps.pr-recent-meta.outputs.tags }}

    - name: build success
      if: steps.build-rc.outcome == 'success'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: |
          ```
          ${{ steps.rc-meta.outputs.tags }}
          ${{ steps.build-rc.outputs.digest }}
          ```
          :hammer_and_wrench: Build Success  

    - name: build error
      if: failure() && steps.build-rc.outcome == 'failure'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: ":x: Build Failure"

    - name: cosign image with key
      id: cosign-rc
      if: inputs.cosign-public-key != '' && steps.build-rc.outcome == 'success'
      env:
        COSIGN_PRIVATE_KEY: ${{ inputs.cosign-private-key }}
        COSIGN_PASSWORD: ${{ inputs.cosign-password }}
        COSIGN_PUBLIC_KEY: ${{ inputs.cosign-public-key }}
        TAGS: ${{ steps.rc-meta.outputs.tags }}
        DIGEST: ${{ steps.build-rc.outputs.digest }}
      shell: bash
      run: |
        cosign sign --yes --key env://COSIGN_PRIVATE_KEY "${TAGS}@${DIGEST}"
        cosign verify --key env://COSIGN_PUBLIC_KEY "${TAGS}@${DIGEST}"

    - name: cosign success
      if: steps.cosign-rc.outcome == 'success'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: ":black_nib: Cosign Success  "

    - name: cosign error
      if: failure() && steps.cosign-rc.outcome == 'failure'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: ":x: Cosign Failure"

    - name: test
      id: test
      if: (inputs.test-flags != '' || inputs.test-args != '') && steps.build-rc.outcome == 'success' && steps.cosign-rc.outcome != 'failure'
      shell: bash
      run: |
        docker run \
          ${{ inputs.test-flags }} \
          ${{ inputs.registry }}/${{ inputs.registry-repo }}@${{ steps.build-rc.outputs.digest }} \
          ${{ inputs.test-args }}

    - name: test success
      if: steps.test.outcome == 'success'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: ":eyes: Test Success  "

    - name: test error
      if: failure() && steps.test.outcome == 'failure'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: ":x: Test Failure"

    - name: create null extra tag
      if: inputs.registry-extra-tag-command == '' && steps.build-rc.outcome == 'success' && steps.cosign-rc.outcome != 'failure' && steps.test.outcome != 'failure'
      shell: bash
      run: |
        echo "EXTRA_TAG=" >> $GITHUB_ENV
        echo "EXTRA_META=" >> $GITHUB_ENV

    - name: create extra tag
      id: extra-tag
      if: inputs.registry-extra-tag-command != '' && steps.build-rc.outcome == 'success' && steps.cosign-rc.outcome != 'failure' && steps.test.outcome != 'failure'
      shell: bash
      run: |
        EXTRA_TAG=$(${{ inputs.registry-extra-tag-command }})
        echo "EXTRA_TAG=$EXTRA_TAG" >> $GITHUB_ENV
        EXTRA_META="${{ inputs.registry }}/${{ inputs.registry-repo }}:${EXTRA_TAG}"
        echo "EXTRA_META=$EXTRA_META" >> $GITHUB_ENV

    - name: extra tag success
      if: steps.extra-tag.outcome == 'success'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: ":label: New version will also be tagged as ${{ env.EXTRA_TAG }}  "

    - name: extra tag error
      if: failure() && steps.extra-tag.outcome == 'failure'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: ":x: Extra Tag Command Failure"

    - name: build release container
      if: steps.build-rc.outcome == 'success' && steps.cosign-rc.outcome != 'failure' && steps.test.outcome != 'failure' && steps.extra-tag.outcome != 'failure'
      uses: docker/build-push-action@v5
      id: build-release
      with:
        file: ${{ inputs.build-file }}
        context: ${{ inputs.build-context }}
        tags: |
          ${{ steps.meta.outputs.tags }}
          ${{ env.EXTRA_META }}
        labels: ${{ steps.meta.outputs.labels }}
        push: true
        github-token: ${{ github.token }}
        provenance: true
        cache-from: |
          type=registry,ref=${{ steps.rc-meta.outputs.tags }}
          type=registry,ref=${{ steps.meta.outputs.tags }}

    - name: build success
      if: steps.build-release.outcome == 'success'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: |
          ```
          ${{ steps.meta.outputs.tags }}
          ${{ env.EXTRA_META }}
          ${{ steps.build-release.outputs.digest }}
          ```
          :hammer_and_wrench: Release Build Success  

    - name: build error
      if: failure() && steps.build-release.outcome == 'failure'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: ":x: Release Build Failure"

    - name: cosign image with key
      id: cosign-release
      if: inputs.cosign-public-key != '' && steps.build-release.outcome == 'success'
      env:
        COSIGN_PRIVATE_KEY: ${{ inputs.cosign-private-key }}
        COSIGN_PASSWORD: ${{ inputs.cosign-password }}
        COSIGN_PUBLIC_KEY: ${{ inputs.cosign-public-key }}
        TAGS: ${{ steps.meta.outputs.tags }}
        DIGEST: ${{ steps.build-release.outputs.digest }}
      shell: bash
      run: |
        cosign sign --yes --key env://COSIGN_PRIVATE_KEY "${TAGS}@${DIGEST}"
        cosign verify --key env://COSIGN_PUBLIC_KEY "${TAGS}@${DIGEST}"

    - name: cosign success
      if: steps.cosign-release.outcome == 'success'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: ":black_nib: Cosign Success  "

    - name: cosign error
      if: failure() && steps.cosign-release.outcome == 'failure'
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: ":x: Cosign Failure"

    - name: github release
      if: steps.build-release.outcome == 'success' && steps.cosign-release.outcome != 'failure'
      uses: actions/github-script@v7
      id: release
      with:
        retries: 3
        github-token: ${{ github.token }}
        script: |
          github.rest.repos.createRelease({
            owner: "${{ github.repository_owner }}",
            repo: "${{ github.event.repository.name }}",
            tag_name: "${{ steps.semantic.outputs.git-tag }}",
            target_commitish: "${{ github.sha }}",
            body: "",
            name: "${{ steps.semantic.outputs.git-tag }}"
          });

    - name: error
      if: failure()
      shell: bash
      run: |
        echo "${SUMMARY}" >> "$GITHUB_STEP_SUMMARY"
      env:
        SUMMARY: |
          ---
          :x: An error occurred during execution! Check the workflow run logs for details!
